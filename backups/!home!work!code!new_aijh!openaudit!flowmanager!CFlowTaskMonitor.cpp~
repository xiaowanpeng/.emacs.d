#include "base_func.h"

#include "thread_value.h"
#include "openbroker/OBClient.h"
#include "openbroker/svr_ctrl.h"
#include "ob_session.h"
#include "ob_kernel.h"
#include "c_uni_socket.h"
#include "tool.h"
#include "socket_pool.h"

#include "dmcext_audit_mgr.h"
#include "FmTaskOp.h"
#include "CFlowTaskMonitor.h"


#define NODE_STS_UNHANDLED 0
#define NODE_STS_RUNNING 2
#define NODE_STS_SUCCESS 3
#define NODE_STS_FAILD 4
#define NODE_STS_HANG_UP 5
#define NODE_STS_INTERRUPT 6
#define NODE_STS_NEED_VERIFY 7

#define TASK_STS_UNHANDLED 0
#define TASK_STS_RUNNING 2
#define TASK_STS_SUCCESS 3
#define TASK_STS_FAILD 4
#define TASK_STS_HANG_UP 5
#define TASK_STS_INTERRUPT 6
#define TASK_STS_NEED_VERIFY 7


#define THREAD_MAX 10
#define SLEEP_SEC 2
#define MAX_TRY_TIME 10

pthread_mutex_t TASK_MTX;

int CFlowTaskMonitor::m_nThreadCount = 0;

CFlowTaskMonitor::CFlowTaskMonitor() 
{
}

CFlowTaskMonitor::~CFlowTaskMonitor()
{
}

int CFlowTaskMonitor::run (
    SOBSession* pSession,
    CBSErrorMsg& cErrorMsg )
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::run ok.");

    if (pthread_mutex_init (
             &TASK_MTX,
             NULL))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call pthread_mutex_init error.");
        return -1;
    }

    CFmTaskList listFmTask;
    while (true)
    {
        sleep(SLEEP_SEC);

        if (m_nThreadCount >= THREAD_MAX)
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","thread has touch max count");
            continue;
        }
        
        listFmTask.clear();

        if (FmTaskOp::get_fmTask (
                 pSession,
                 "subtask_id <> 0 and sts = 0",
                 listFmTask,
                 cErrorMsg))
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","call FmTaskOp::get_fmTask error.");
            continue;
        }

        if (runTasks (
                 pSession,
                 listFmTask,
                 cErrorMsg))
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","call runTasks error.");
            continue;
        }

    }
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::run ok.");
    return 0;
}

int CFlowTaskMonitor::runTasks (
    SOBSession* pSession,
    const CFmTaskList& listFmTask,
    CBSErrorMsg& cErrorMsg )
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::runTasks ok.");

    

    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::runTasks ok.");
    return 0;
}

int CFlowTaskMonitor::incThreadCount ()
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::incThreadCount ok.");

    int nTryTime = 0;
    bool isInc = false;
    while (nTryTime < MAX_TRY_TIME)
    {
        nTryTime ++;
        if (pthread_mutex_trylock (&TASK_MTX))
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","call pthread_mutex_trylock error.");
            sleep(1);
            continue;
        }

        if (m_nThreadCount < THREAD_MAX)
        {
            m_nThreadCount ++;
            isInc = true;
        }
        pthread_mutex_unlock(&TASK_MTX);

        break;
    }

    if (nTryTime == MAX_TRY_TIME)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","can't lock mutex");
        return -1;
    }

    if (!isInc)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel",AISTD string("thread number touch the max number: " + itoa(THREAD_MAX)).c_str());
        return -1;
    }
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::incThreadCount ok.");
    return 0;
}

int CFlowTaskMonitor::decThreadCount ()
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::decThreadCount ok.");

    pthread_mutex_lock(&TASK_MTX);
    m_nThreadCount --;
    pthread_mutex_unlock(&TASK_MTX);
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::decThreadCount ok.");
    return 0;
}
