#ifndef _INC_FLOW_TASK_MONITOR_H_
#define _INC_FLOW_TASK_MONITOR_H_

#include <map>
#include <pthread.h>
#include "dmcext_audit_mgr.h"

class SOBSession;

class TaskAndInst
{
public:
    int64 llTaskId;
    int32 nInstId;

    bool operator < (const TaskAndInst& obj) const
    {
        if (this->llTaskId < obj.llTaskId)
        {
            return true;
        }
        else if (this->llTaskId == obj.llTaskId)
        {
            if (this->nInstId < obj.nInstId)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
        else
        {
            return false;
        }
    };
};

typedef std::map<TaskAndInst, pthread_t> Task2Thread;
typedef std::map<TaskAndInst, pthread_t>::iterator Task2ThreadItr;

typedef std::vector<int> IntVec;

class CFlowTaskMonitor
{
public:
    CFlowTaskMonitor();
    ~CFlowTaskMonitor();

    int run(SOBSession* pSession);

    // 由外部调用，更新节点状态为成功，以后要放到接口服务中
    int updateNodeSucc
      (
       SOBSession* pSession,
       const AISTD string& strXmlParam,
       const CFmTaskNodeInfo& fmTaskNodeInfo, //this param is temp
       CBSErrorMsg& cErrorMsg);
    
private:

    int get_unhandledNode
      (SOBSession* pSession,
       CFmTaskNodeInfoList& listFmTaskNodeInfo);

    int init_thread();
    int init_workThread(int nCount);
    int init_svrThread();
    
    static void* runNode(void* pArg);
    int runSingleNode
      (SOBSession* pSession,
       const CFmTaskNodeInfo& fmTaskNodeInfo);
    static void* runSvr(void* pArg);
    static void cleanupFunc(void* pArg);

    int directExec
      (SOBSession* pSession,
       const ob_whereCond& cFullSql,
       int& nExecNum,
       CBSErrorMsg& cErrorMsg );

    int init_sigaction();
    static void sigHandle(int sig);

    int init_socket(int& fdListen);

    static void* opHandle(void* pArg);
    
    int call_opFunc(const AISTD string& strBuf);
    
private:
    //以下是与前台操作相关的函数

    // 暂停
    int node_pause
      (SOBSession* pSession,
       int64 llTaskId,
       int32 nInstId,
       CBSErrorMsg& cErrorMsg );

    // 重置
    int node_reset
      (SOBSession* pSession,
       int64 llTaskId,
       int32 nInstId,
       CBSErrorMsg& cErrorMsg );

    // 重处理
    int node_rehandle
      (SOBSession* pSession,
       int64 llTaskId,
       int32 nInstId,
       CBSErrorMsg& cErrorMsg );

    // 恢复
    int node_resume
      (SOBSession* pSession,
       int64 llTaskId,
       int32 nInstId,
       CBSErrorMsg& cErrorMsg );

    // 停止
    int node_stop
      (SOBSession* pSession,
       int64 llTaskId,
       int32 nInstId,
       CBSErrorMsg& cErrorMsg );

    // 审核通过
    int node_checkPass
      (SOBSession* pSession,
       int64 llTaskId,
       int32 nInstId,
       CBSErrorMsg& cErrorMsg );

    // 审核不通过
    int node_checkNoPass
      (SOBSession* pSession,
       int64 llTaskId,
       int32 nInstId,
       CBSErrorMsg& cErrorMsg );

    
private:
    CFmTaskNodeInfoList m_listFmTaskNodeInfo;
    Task2Thread m_task2Thread;
    int m_fdListen;
    IntVec m_listFdConnect;
};

#endif
