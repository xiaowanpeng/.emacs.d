#include <memory.h>
#include <sys/signal.h>
#include "base_func.h"

#include "thread_value.h"
#include "openbroker/OBClient.h"
#include "openbroker/svr_ctrl.h"
#include "ob_session.h"
#include "ob_kernel.h"
#include "c_uni_socket.h"
#include "tool.h"
#include "socket_pool.h"

#include "dmcext_audit_mgr.h"
#include "FmTaskOp.h"
#include "CFlowTaskMonitor.h"

#include "node_implement_mgr.h"
#include <dlfcn.h>
#include <iostream>
#include <string.h>
#include <sstream>
#include <stdlib.h>
#include <vector>
#define Max_Size 1024


#define NODE_STS_UNHANDLED 0
#define NODE_STS_RUNNING 2
#define NODE_STS_SUCCESS 3
#define NODE_STS_FAILD 4
#define NODE_STS_HANG_UP 5
#define NODE_STS_INTERRUPT 6
#define NODE_STS_NEED_CHECK 7

#define TASK_STS_UNHANDLED 0
#define TASK_STS_RUNNING 2
#define TASK_STS_SUCCESS 3
#define TASK_STS_FAILD 4
#define TASK_STS_HANG_UP 5
#define TASK_STS_INTERRUPT 6
#define TASK_STS_NEED_CHECK 7

#define LISTEN_PORT 8888
#define LISTEN_SIZE 10
#define MAX_BUF_SIZE 128

#define WORK_THREAD_MAX 3
#define SOCK_THREAD_MAX 3

#define SLEEP_SEC 2
typedef std::vector<AISTD string> vector;

pthread_mutex_t NODE_LIST_MTX;
pthread_mutex_t TASK_THREAD_MTX;
pthread_mutex_t SOCK_THREAD_MTX;

#define OBD_SESSION_NAME "_Session"
extern int64 llTaskId;
extern int32 nInstId;
extern AISTD string interface;

vector  CutString(AISTD string source, AISTD string separator)
{
    vector result;
    AISTD string cut;
    int pos=source.find(separator);
    while(pos!=-1)
    {
        cut=source.substr(0,pos);
	    source=source.substr(pos+separator.length());
		pos=source.find(separator);
	    result.push_back(cut);
    }
	result.push_back(source);
	return result;
}
bool InterExec(const AISTD string& dlname,const AISTD string& Interfunc)
{
    std::cout<<"Interfunc: "<<Interfunc<<std::endl;
    SOBSession *pSession;
    CThreadValueHolder cThreadValueHolder; 
    try                                   
    {         	                 
        if (CThreadValueMgr::set_value(OBD_SESSION_NAME, SOBSession()) < 0)                    
        {                                                                                              
            LogAppend(FATAL_LEVEL, "DebugInfo", "CFlowTaskMonitor::runNode 初始化数据库容器错误!");                  
            return NULL;
        }                                                                                       
        pSession = CThreadValueMgr::get_value<SOBSession>(OBD_SESSION_NAME);                   
        pSession->m_pDbConn = pSession->get_dbConn();                                         
    }                                                                                           
    catch(...)                                                                                
    {                                                                                        
        LogAppend(FATAL_LEVEL, "DebugInfo", "初始化数据库容器错误!");
        return NULL;
    }                                                     

	CBSErrorMsg cErrorMsg;
//	vector result=CutString(strBuf,"|"); 
  //  int64 llTaskId            = atoi((result[0]).c_str()); 
    //int32 nInstId             = atoi((result[1]).c_str());
    //AISTD string   interface  = result[2];
	
	char szLibName[Max_Size];    // "/app/sunqing/work/products/openboss/openaudit/sunqing/libnode_implement_mgrD.so"; // 配置业务实现库 ： 具体的类名如何配置和确定？每个类单独一个库么？明天试试
	char prefix[1024]="/app/sunqing/work/products/openboss/openaudit_sunqing/sunqing/";
	strcat(prefix,dlname.c_str());
	strcpy(szLibName,prefix);
	void* p_busi = dlopen(szLibName, RTLD_LAZY);
	if (!p_busi) {
	     std::cout << "Cannot load library: " << dlerror() << '\n';
	     return 1;
	}
	dlerror();
	p_new* new_busi = (p_new*) dlsym(p_busi, "New");//函数指针指向与new（）这个函数。
    const char* dlsym_error = dlerror();
	if (dlsym_error) {
	     std::cout << "Cannot load symbol create: " << dlsym_error << '\n';
	     return 1;
	}

	p_delete* delete_busi = (p_delete*) dlsym(p_busi, "Delete");
	dlsym_error = dlerror();
	if (dlsym_error) {
	     std::cout << "Cannot load symbol destroy: " << dlsym_error << '\n';
	     return 1;
    }
	CNodeAbstractBase* pobj = new_busi();//这里应该需要接受参数，用于构造该对象，如任务号等，也可以放在init函数里
	std::cout<<"it's for testing ,and it runs well!!!" << std::endl;
//	if(strcmp(Interfunc.c_str(),"PAUSE") == 0)
	{
		std::cout<<"llTaskId: "<<llTaskId<<std::endl;
		pobj->pause(pSession,llTaskId,nInstId,cErrorMsg);
	}
	else if("RESET" == Interfunc)
  	    pobj->reset(pSession,llTaskId,nInstId,cErrorMsg);
	else if("REHANDLE" == Interfunc)
	    pobj->rehandle(pSession,llTaskId,nInstId,cErrorMsg);
	else if("RESUME" == Interfunc)
	    pobj->resume(pSession,llTaskId,nInstId,cErrorMsg);
	else if("CHECKPASS" == Interfunc)
	    pobj->checkPass(pSession,llTaskId,nInstId,cErrorMsg);
	else if("CHECKNOPASS" == Interfunc)
	    pobj->checkNoPass(pSession,llTaskId,nInstId,cErrorMsg);
	std::cout<<"it runs till here!"<<std::endl;
	delete_busi(pobj);
	dlclose(p_busi);
    return 0;
}
CFlowTaskMonitor::CFlowTaskMonitor() : m_sockThreadCnt(0)
{
}

CFlowTaskMonitor::~CFlowTaskMonitor()
{
}

int CFlowTaskMonitor::run (SOBSession* pSession)
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::run ok.");
    CBSErrorMsg cErrorMsg;
    if (init_socket (m_fdListen))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call init_socket error.");
        return -1;
    }

    if (init_sigaction ())
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call init_sigaction error.");
        return -1;
    }

    pthread_mutexattr_t pthreadAttr;
    if (pthread_mutexattr_init (&pthreadAttr))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call pthread_mutexattr_init error.");
        return -1;
    }

    if (pthread_mutexattr_settype (&pthreadAttr, PTHREAD_MUTEX_ERRORCHECK))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call pthread_mutexattr_settype error.");
        return -1;
    }
    
    if (pthread_mutex_init (
            &NODE_LIST_MTX,
            &pthreadAttr))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call pthread_mutex_init NODE_LIST_MTX error.");
        return -1;
    }

    if (pthread_mutex_init (
            &TASK_THREAD_MTX,
            &pthreadAttr))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call pthread_mutex_init NODE_LIST_MTX error.");
        return -1;
    }

    
    if (init_thread ())
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call init_thread error.");
        return -1;
    }

    int nTmp = 0;
    while (true)
    {
        sleep(SLEEP_SEC);

        pthread_mutex_lock(&NODE_LIST_MTX);
        
        if (!m_listFmTaskNodeInfo.empty())
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","m_listFmTaskNodeInfo is not empty.");
            pthread_mutex_unlock(&NODE_LIST_MTX);
            continue;
        }

        pthread_mutex_unlock(&NODE_LIST_MTX);
        
        if (nTmp == 3000)
        {
            break;
        }

        nTmp ++;

/*        pthread_mutex_lock(&NODE_LIST_MTX);
        
        if (get_unhandledNode (pSession, m_listFmTaskNodeInfo))
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","call get_unhandledNode error.");
            pthread_mutex_unlock(&NODE_LIST_MTX);
            return -1;
        }
        
        pthread_mutex_unlock(&NODE_LIST_MTX);*/
    
}
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::run ok.");
    return 0;
}

int CFlowTaskMonitor::init_socket (int& fdListen)
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::init_socket ok.");

    m_fdListen = socket(AF_INET, SOCK_STREAM, 0);
    if (m_fdListen == -1)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel",AISTD string(AISTD string("create socket error : ") + AISTD string(strerror(errno))).c_str());
        return -1;
    }

    struct sockaddr_in servaddr;
    memset(&servaddr, 0, sizeof(servaddr));

    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(LISTEN_PORT);

    int nRet = 0;
    nRet = bind(m_fdListen, (struct sockaddr*)&servaddr, sizeof(servaddr));
    if (-1 == nRet)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel",AISTD string(AISTD string("bind socket error : ") + AISTD string(strerror(errno))).c_str());
        return -1;
    }

    nRet = listen(m_fdListen, LISTEN_SIZE);
    if (-1 == nRet)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel",AISTD string(AISTD string("listen socket error : ") + AISTD string(strerror(errno))).c_str());
        return -1;
    }
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::init_socket ok.");
    return 0;
}


int CFlowTaskMonitor::get_unhandledNode (SOBSession* pSession, CFmTaskNodeInfoList& listFmTaskNodeInfo)
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::get_unhandledNode ok.");

    CBSErrorMsg cErrorMsg;
    
    std::auto_ptr< CDmcextTemplateMgr<CFmTaskNodeInfoList> > tFmTaskNodeInfo = CDmcextAuditMgr::getFmTaskNodeInfo(pSession);
    CFmTaskNodeInfo cFmTaskNodeInfo;
    cFmTaskNodeInfo.set_sts(NODE_STS_UNHANDLED);
    
    if(tFmTaskNodeInfo->selectFromTable(
           cFmTaskNodeInfo,
           "parent_inst_id = parent_inst_id_succnum",
           listFmTaskNodeInfo,
           cErrorMsg))
    {
        DMCEXT_ERROR_LOG("tFmTaskNodeInfo->selectFromTable");
    }

    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::get_unhandledNode ok.");
    return 0;
}

int CFlowTaskMonitor::init_thread ()
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::init_thread ok.");

/*    if (init_workThread(WORK_THREAD_MAX))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","init work thread error.");
        return -1;
        }*/

    if (init_svrThread ())
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call init_svrThread error.");
        return -1;
    }

    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::init_thread ok.");
    return 0;
}

int CFlowTaskMonitor::init_workThread (int nCount)
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::init_workThread ok.");

    // work thread
    for (int i = 0; i < nCount; i++)
    {
        pthread_t tThread;

        if (pthread_create (
                &tThread,
                NULL,
                &CFlowTaskMonitor::runNode,
                (void*)this))
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","call pthread_create error.");
            return -1;
        }
    }
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::init_workThread ok.");
    return 0;
}

int CFlowTaskMonitor::init_svrThread ()
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::init_svrThread ok.");

    pthread_t tThread;

    if (pthread_create (
            &tThread,
            NULL,
            &CFlowTaskMonitor::runSvr,
            (void*)this))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call pthread_create error.");
        return -1;
    }
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::init_svrThread ok.");
    return 0;
}


void* CFlowTaskMonitor::runNode (void* pArg)
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::runNode ok.");

    pthread_cleanup_push(&CFlowTaskMonitor::cleanupFunc, pArg);

    CFlowTaskMonitor* pThis = (CFlowTaskMonitor*) pArg;

    pthread_t selfT = pthread_self();

    SOBSession *pSession;
    CThreadValueHolder cThreadValueHolder; 
    try                                   
    {         	                 
        if (CThreadValueMgr::set_value(OBD_SESSION_NAME, SOBSession()) < 0)                    
        {                                                                                              
            LogAppend(FATAL_LEVEL, "DebugInfo", "CFlowTaskMonitor::runNode 初始化数据库容器错误!");                  
            return NULL;
        }                                                                                       
        pSession = CThreadValueMgr::get_value<SOBSession>(OBD_SESSION_NAME);                   
        pSession->m_pDbConn = pSession->get_dbConn();                                         
    }                                                                                           
    catch(...)                                                                                
    {                                                                                        
        LogAppend(FATAL_LEVEL, "DebugInfo", "初始化数据库容器错误!");
        return NULL;
    }                                                     

    TaskAndInst preKey;
    preKey.llTaskId = 0;
    preKey.nInstId = 0;

    Task2ThreadItr itr;
    
    while (true)
    {
        sleep(2);

        pthread_mutex_lock(&TASK_THREAD_MTX);

        itr = pThis->m_task2Thread.find(preKey);
        if (itr != pThis->m_task2Thread.end())
        {
            pThis->m_task2Thread.erase(itr);
        }

        pthread_mutex_unlock(&TASK_THREAD_MTX);
        
        bool isListEmpty = false;
        CFmTaskNodeInfo cFmTaskNodeInfo;
            
        pthread_mutex_lock(&NODE_LIST_MTX);

        if (pThis->m_listFmTaskNodeInfo.empty())
        {
            isListEmpty = true;
        }
        else
        {
            cFmTaskNodeInfo = *(pThis->m_listFmTaskNodeInfo.begin());
            pThis->m_listFmTaskNodeInfo.erase(pThis->m_listFmTaskNodeInfo.begin());
        }
    
        pthread_mutex_unlock(&NODE_LIST_MTX);

        if (isListEmpty)
        {
            continue;
        }

        preKey.llTaskId = cFmTaskNodeInfo.get_taskId();
        preKey.nInstId = cFmTaskNodeInfo.get_instId();

        pthread_mutex_lock(&TASK_THREAD_MTX);
        
        pThis->m_task2Thread[preKey] = selfT;

        pthread_mutex_unlock(&TASK_THREAD_MTX);

        if (pThis->runSingleNode (pSession, cFmTaskNodeInfo))
        {
            pSession->get_dbConn()->rollback();
            LogAppend(DEBUG_LEVEL,"InfoLevel","call (CFlowTaskMonitor*)pThis->runSingleNode error.");
            continue;
        }
        
        CBSErrorMsg cErrorMsg;
        pThis->updateNodeSucc(pSession, "", cFmTaskNodeInfo, cErrorMsg);

        pSession->get_dbConn()->commit();
    }

    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::runNode ok.");

    pthread_cleanup_pop(0);
    
    return NULL;
}

void* CFlowTaskMonitor::runSvr (void* pArg)
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::runSvr ok.");

    CFlowTaskMonitor* pThis = (CFlowTaskMonitor*) pArg;

    int fdConnect;
    while (true)
    {
        fdConnect = accept(pThis->m_fdListen, NULL, NULL);
        if (-1 == fdConnect)
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel",AISTD string(AISTD string("accept socket error : ") + AISTD string(strerror(errno))).c_str());
            continue;
        }

        bool isFull = false;

        LogAppend(DEBUG_LEVEL,"InfoLevel",AISTD string(AISTD string("runsvr m_sockThreadCnt: ") + AISTD string(itoa(pThis->m_sockThreadCnt))).c_str());

        pthread_mutex_lock(&SOCK_THREAD_MTX);

        if (pThis->m_sockThreadCnt < SOCK_THREAD_MAX)
        {
            pThis->m_listFdConnect.push_back(fdConnect);
            pThis->m_sockThreadCnt = pThis->m_sockThreadCnt + 1;            
        }
        else
        {
            isFull = true;
        }

        pthread_mutex_unlock(&SOCK_THREAD_MTX);

        if (isFull)
        {
            if (send(fdConnect, "too much operator!", strlen("too much operator!"), 0) < 0)
            {
                LogAppend(DEBUG_LEVEL,"InfoLevel","too much operator!");
            }

            continue;
        }
                
        pthread_t tThread;
        if (pthread_create (
                &tThread,
                NULL,
                &CFlowTaskMonitor::opHandle,
                pArg))
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","create opHandle thread error.");

            pthread_mutex_lock(&SOCK_THREAD_MTX);

            if (pThis->m_listFdConnect.size() > 0)
            {
                pThis->m_listFdConnect.erase(pThis->m_listFdConnect.end());
                pThis->m_sockThreadCnt = pThis->m_sockThreadCnt - 1;
            }

            pthread_mutex_unlock(&SOCK_THREAD_MTX);
        }
    }
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::runSvr ok.");

    return 0;
}


int CFlowTaskMonitor::runSingleNode (SOBSession* pSession, const CFmTaskNodeInfo& fmTaskNodeInfo)
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::runSingleNode ok.");

    CBSErrorMsg cErrorMsg;
    CBSDateTime dtmCur;
    if (get_databaseTime((*pSession->get_dbConn()),
                         dtmCur, 
                         cErrorMsg))
    {
        cErrorMsg.set_hint("获取系统时间失败!");
        return -1;
    }

    int nExecNum = 0;
    ob_whereCond cFullSql;
    cFullSql << OCS(" update fm_task_node_info set begin_date = sysdate, sts = ")
             << NODE_STS_RUNNING
             << OCS(" where task_id = ")
             << fmTaskNodeInfo.get_taskId()
             << OCS(" and subtask_id = ")
             << fmTaskNodeInfo.get_subtaskId()
             << OCS(" and plan_id = ")
             << fmTaskNodeInfo.get_planId()
             << OCS(" and inst_id = ")
             << fmTaskNodeInfo.get_instId()
             << OCS(" and sts = ")
             << NODE_STS_UNHANDLED;

    if (directExec (
            pSession,
            cFullSql,
            nExecNum,
            cErrorMsg))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call directExec error.");
        return -1;
    }

    if (nExecNum != 1)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","update task_node_info running error, update num is not 1");
        return -1;
    }

    if (fmTaskNodeInfo.get_nodeType() == "begin"
        || fmTaskNodeInfo.get_nodeType() == "end")
    {
        int begSts = 0;
        int endSts = 0;
        ob_whereCond cFullSql;
        if (fmTaskNodeInfo.get_nodeType() == "begin")
        {
            cFullSql << OCS(" update fm_task set begin_date = sysdate, sts = ");
            begSts = TASK_STS_UNHANDLED;
            endSts = TASK_STS_RUNNING;
        }
        else
        {
            cFullSql << OCS(" update fm_task set end_date = sysdate, sts = ");
            begSts = TASK_STS_RUNNING;
            endSts = TASK_STS_SUCCESS;
        }
        
        
        cFullSql << endSts
                 << OCS(" where task_id = ")
                 << fmTaskNodeInfo.get_taskId()
                 << OCS(" and subtask_id = ")
                 << fmTaskNodeInfo.get_subtaskId()
                 << OCS(" and plan_id = ")
                 << fmTaskNodeInfo.get_planId()
                 << OCS(" and sts = ")
                 << begSts;

        if (directExec (
                pSession,
                cFullSql,
                nExecNum,
                cErrorMsg))
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","call directExec error.");
            return -1;
        }

        if (nExecNum != 1)
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","update task running error, update num is not 1");
            return -1;
        }
        
    }

    pSession->get_dbConn()->commit();
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","*********** start call node **************");
    LogAppend(DEBUG_LEVEL,"InfoLevel","=========== node running ============");

    sleep(5);
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","*********** end call node **************");
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::runSingleNode ok.");
    return 0;
}

int CFlowTaskMonitor::updateNodeSucc (
    SOBSession* pSession,
    const AISTD string& strXmlParam,
    const CFmTaskNodeInfo& fmTaskNodeInfo,
    CBSErrorMsg& cErrorMsg )
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::updateNodeSucc ok.");

    /*
      strXmlParam 参数中会有 plan_id, task_id, subtask_id,
      flow_id, node_inst_id, release_status
      这个函数要做的事情是：
      1. 更新节点状态
      2. 更新子节点的父节点成功个数，如果是分支节点，则需要
      根据表达式的结果更新子节点的父节点成功个数，及汇总节点
      的父节点个数。
    */

    int32 nFlowId = 18;
    int16 nReleaseStatus = 1;

    std::auto_ptr< CDmcextTemplateMgr<CFmFlowNodeRelationList> > tFmFlowNodeRelation = CDmcextAuditMgr::getFmFlowNodeRelation(pSession);
    CFmFlowNodeRelation cFmFlowNodeRelation;
    CFmFlowNodeRelationList listcFmFlowNodeRelation;
    cFmFlowNodeRelation.set_flowId(nFlowId);
    cFmFlowNodeRelation.set_instId(fmTaskNodeInfo.get_instId());
    cFmFlowNodeRelation.set_releaseStatus(nReleaseStatus);

    if(tFmFlowNodeRelation->selectFromTable(
           cFmFlowNodeRelation,
           "sysdate between valid_date and expire_date",
           listcFmFlowNodeRelation,
           cErrorMsg))
    {
        DMCEXT_ERROR_LOG("tFmFlowNodeRelation->selectFromTable");
    }

    int nSuccNum = 0;
    int nExecNum = 0;
    CFmFlowNodeRelationList::iterator itr;
    for (itr = listcFmFlowNodeRelation.begin();
         itr != listcFmFlowNodeRelation.end();
         itr ++)
    {
        if (fmTaskNodeInfo.get_nodeType() == "split"
            && itr->get_condExpr() == "false")
        {
            continue;
        }

        nSuccNum ++;

        ob_whereCond cFullSql;
        cFullSql << OCS(" update fm_task_node_info set parent_inst_id_succnum = parent_inst_id_succnum + 1 ")
                 << OCS(" where task_id = ")
                 << fmTaskNodeInfo.get_taskId()
                 << OCS(" and subtask_id = ")
                 << fmTaskNodeInfo.get_subtaskId()
                 << OCS(" and plan_id = ")
                 << fmTaskNodeInfo.get_planId()
                 << OCS(" and inst_id = ")
                 << itr->get_childInstId()
                 << OCS(" and sts = ")
                 << NODE_STS_UNHANDLED;

        if (directExec (
                pSession,
                cFullSql,
                nExecNum,
                cErrorMsg))
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","call directExec error.");
            return -1;
        }

        if (nExecNum != 1)
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","update parent_inst_id_succnum error, update num is not 1");
            return -1;
        }
    }

    if (fmTaskNodeInfo.get_nodeType() == "split" and nSuccNum > 0)
    {
        ob_whereCond cFullSql;
        cFullSql << OCS(" update fm_task_node_info set parent_inst_id = ")
                 << nSuccNum
                 << OCS(" where task_id = ")
                 << fmTaskNodeInfo.get_taskId()
                 << OCS(" and subtask_id = ")
                 << fmTaskNodeInfo.get_subtaskId()
                 << OCS(" and plan_id = ")
                 << fmTaskNodeInfo.get_planId()
                 << OCS(" and inst_id = ")
                 << OCS(" nvl((select a.relid from fm_flow_node_info a where a.flow_id = ")
                 << nFlowId
                 << OCS(" and a.release_status = ")
                 << nReleaseStatus
                 << OCS(" and a.inst_id = ")
                 << fmTaskNodeInfo.get_instId()
                 << OCS(" and sysdate between a.valid_date and a.expire_date ), -1)");

        int nUpNum = 0;
        if (directExec (
                pSession,
                cFullSql,
                nUpNum,
                cErrorMsg))
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","call directExec error.");
            return -1;
        }

        if (nUpNum != 1)
        {
            LogAppend(DEBUG_LEVEL,"InfoLevel","update join_node's parent_inst_id error, update num is not 1");
            return -1;
        }
    }

    // 更新节点状态为成功 
    std::auto_ptr< CDmcextTemplateMgr<CFmTaskNodeInfoList> > tFmTaskNodeInfo = CDmcextAuditMgr::getFmTaskNodeInfo(pSession);
    CFmTaskNodeInfo cFmTaskNodeInfoOld;
    CFmTaskNodeInfo cFmTaskNodeInfoNew;

    cFmTaskNodeInfoOld.set_taskId(fmTaskNodeInfo.get_taskId());
    cFmTaskNodeInfoOld.set_subtaskId(fmTaskNodeInfo.get_subtaskId());
    cFmTaskNodeInfoOld.set_instId(fmTaskNodeInfo.get_instId());
    cFmTaskNodeInfoOld.set_planId(fmTaskNodeInfo.get_planId());


    CBSDateTime dtmCur;
    if (get_databaseTime((*pSession->get_dbConn()),
                         dtmCur, 
                         cErrorMsg))
    {
        cErrorMsg.set_hint("获取系统时间失败!");
        return -1;
    }

    cFmTaskNodeInfoNew.set_sts(NODE_STS_SUCCESS);
    cFmTaskNodeInfoNew.set_endDate(dtmCur);

    if(tFmTaskNodeInfo->updateToTable(
           cFmTaskNodeInfoOld,
           cFmTaskNodeInfoNew,
           "",
           cErrorMsg))
    {
        DMCEXT_ERROR_LOG("tFmTaskNodeInfo->updateToTable");
    }

    pSession->get_dbConn()->commit();
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::updateNodeSucc ok.");
    return 0;
}

int CFlowTaskMonitor::directExec (
    SOBSession* pSession,
    const ob_whereCond& cFullSql,
    int& nExecNum,
    CBSErrorMsg& cErrorMsg )
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::directExec ok.");

    try
    {
        ob_kernel<CFmPlanList> cKernel( *pSession->get_dbConn(), SCHEME_NAME_AIJH);
        nExecNum = cKernel.direct_execExt(cFullSql);
    }
    catch(CBSErrorMsg& cNewErrorMsg)
    {
        cErrorMsg = cNewErrorMsg;
        return -1;
    }

    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::directExec ok.");
    return 0;
}

int CFlowTaskMonitor::init_sigaction ()
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::init_sigaction ok.");

    struct sigaction actions;
    memset(&actions, 0, sizeof(actions));

    sigemptyset(&actions.sa_mask);
    actions.sa_flags = 0;
    actions.sa_handler = &CFlowTaskMonitor::sigHandle;

    sigaction(SIGUSR1, &actions, NULL);
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::init_sigaction ok.");
    return 0;
}

void CFlowTaskMonitor::sigHandle (int sig)
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::sigHandle ok.");

    if (SIGUSR1 != sig)
    {
        return;
    }

    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::sigHandle ok.");

    pthread_exit(0);

    return;
}

void CFlowTaskMonitor::cleanupFunc (void* pArg)
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::cleanupFunc ok.");

    CFlowTaskMonitor* pThis = (CFlowTaskMonitor*) pArg;
    pthread_t selfT = pthread_self();

    Task2ThreadItr itr;

    pthread_mutex_lock(&TASK_THREAD_MTX);
    
    for (itr = pThis->m_task2Thread.begin(); itr != pThis->m_task2Thread.end(); itr ++)
    {
        if (itr->second == selfT)
        {
            pThis->m_task2Thread.erase(itr);
            break;
        }
    }

    pthread_mutex_unlock(&TASK_THREAD_MTX);

    pthread_mutex_unlock(&NODE_LIST_MTX);

    // 杀掉一个线程后还要再重新起一个线程
    if (pThis->init_workThread (1))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call pThis->init_workThread error.");
        return ;
    }

    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::cleanupFunc ok.");
    return;
}

int CFlowTaskMonitor::node_pause (
    SOBSession* pSession,
    int64 llTaskId,
    int32 nInstId,
    CBSErrorMsg& cErrorMsg )
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::node_pause ok.");

    int nExecNum = 0;
    ob_whereCond cFullSql;
    cFullSql << OCS(" update fm_task_node_info set sts = ")
             << NODE_STS_HANG_UP
             << OCS(" where subtask_id = ")
             << llTaskId
             << OCS(" and inst_id = ")
             << nInstId
             << OCS(" and sts in ( ")
             << NODE_STS_UNHANDLED
             << OCS(" , ")
             << NODE_STS_RUNNING
             << OCS(" )");

    if (directExec (
            pSession,
            cFullSql,
            nExecNum,
            cErrorMsg))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call directExec error.");
        return -1;
    }

    if (nExecNum != 1)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","update task_node_info hang up error, update num is not 1");
        return -1;
    }

    pSession->get_dbConn()->commit();

    TaskAndInst key;
    key.llTaskId = llTaskId;
    key.nInstId = nInstId;

    pthread_mutex_lock(&TASK_THREAD_MTX);
    
    Task2ThreadItr itr = m_task2Thread.find(key);
    if (itr != m_task2Thread.end())
    {
        pthread_kill(itr->second, SIGUSR1);
    }
    else
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","can't find thread.");
    }

    pthread_mutex_unlock(&TASK_THREAD_MTX);
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::node_pause ok.");
    return 0;
}

int CFlowTaskMonitor::node_reset (
    SOBSession* pSession,
    int64 llTaskId,
    int32 nInstId,
    CBSErrorMsg& cErrorMsg )
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::node_reset ok.");

    int nExecNum = 0;
    ob_whereCond cFullSql;
    cFullSql << OCS(" update fm_task_node_info set sts = ")
             << NODE_STS_UNHANDLED
             << OCS(" where subtask_id = ")
             << llTaskId
             << OCS(" and inst_id = ")
             << nInstId
             << OCS(" and sts = ")
             << NODE_STS_SUCCESS;

    if (directExec (
            pSession,
            cFullSql,
            nExecNum,
            cErrorMsg))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call directExec error.");
        return -1;
    }

    if (nExecNum != 1)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","update task_node_info reset error, update num is not 1");
        return -1;
    }

    pSession->get_dbConn()->commit();

    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::node_reset ok.");
    return 0;
}

int CFlowTaskMonitor::node_rehandle (
    SOBSession* pSession,
    int64 llTaskId,
    int32 nInstId,
    CBSErrorMsg& cErrorMsg )
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::node_rehandle ok.");

    int nExecNum = 0;
    ob_whereCond cFullSql;
    cFullSql << OCS(" update fm_task_node_info set sts = ")
             << NODE_STS_UNHANDLED
             << OCS(" where subtask_id = ")
             << llTaskId
             << OCS(" and inst_id = ")
             << nInstId
             << OCS(" and sts = ")
             << NODE_STS_FAILD;

    if (directExec (
            pSession,
            cFullSql,
            nExecNum,
            cErrorMsg))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call directExec error.");
        return -1;
    }

    if (nExecNum != 1)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","update task_node_info rehandle error, update num is not 1");
        return -1;
    }

    pSession->get_dbConn()->commit();
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::node_rehandle ok.");
    return 0;
}

int CFlowTaskMonitor::node_resume (
    SOBSession* pSession,
    int64 llTaskId,
    int32 nInstId,
    CBSErrorMsg& cErrorMsg )
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::node_resume ok.");

    int nExecNum = 0;
    ob_whereCond cFullSql;
    cFullSql << OCS(" update fm_task_node_info set sts = ")
             << NODE_STS_UNHANDLED
             << OCS(" where subtask_id = ")
             << llTaskId
             << OCS(" and inst_id = ")
             << nInstId
             << OCS(" and sts = ")
             << NODE_STS_HANG_UP;

    if (directExec (
            pSession,
            cFullSql,
            nExecNum,
            cErrorMsg))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call directExec error.");
        return -1;
    }

    if (nExecNum != 1)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","update task_node_info resume error, update num is not 1");
        return -1;
    }

    pSession->get_dbConn()->commit();
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::node_resume ok.");
    return 0;
}

int CFlowTaskMonitor::node_stop (
    SOBSession* pSession,
    int64 llTaskId,
    int32 nInstId,
    CBSErrorMsg& cErrorMsg )
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::node_stop ok.");

    int nExecNum = 0;
    ob_whereCond cFullSql;
    cFullSql << OCS(" update fm_task_node_info set sts = ")
             << NODE_STS_INTERRUPT
             << OCS(" where subtask_id = ")
             << llTaskId
             << OCS(" and inst_id = ")
             << nInstId
             << OCS(" and sts = ")
             << NODE_STS_RUNNING;

    if (directExec (
            pSession,
            cFullSql,
            nExecNum,
            cErrorMsg))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call directExec error.");
        return -1;
    }

    if (nExecNum != 1)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","update task_node_info interrupt error, update num is not 1");
        return -1;
    }

    pSession->get_dbConn()->commit();

    TaskAndInst key;
    key.llTaskId = llTaskId;
    key.nInstId = nInstId;

    pthread_mutex_lock(&TASK_THREAD_MTX);
    
    Task2ThreadItr itr = m_task2Thread.find(key);
    if (itr != m_task2Thread.end())
    {
        pthread_kill(itr->second, SIGUSR1);
    }
    else
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","can't find thread.");
    }

    pthread_mutex_unlock(&TASK_THREAD_MTX);
    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::node_stop ok.");
    return 0;
}

int CFlowTaskMonitor::node_checkPass (
    SOBSession* pSession,
    int64 llTaskId,
    int32 nInstId,
    CBSErrorMsg& cErrorMsg )
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::node_checkPass ok.");
    
    int nExecNum = 0;
    ob_whereCond cFullSql;
    cFullSql << OCS(" update fm_task_node_info set sts = ")
             << NODE_STS_SUCCESS
             << OCS(" where subtask_id = ")
             << llTaskId
             << OCS(" and inst_id = ")
             << nInstId
             << OCS(" and sts = ")
             << NODE_STS_NEED_CHECK;

    if (directExec (
            pSession,
            cFullSql,
            nExecNum,
            cErrorMsg))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call directExec error.");
        return -1;
    }

    if (nExecNum != 1)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","update task_node_info checkpass error, update num is not 1");
        return -1;
    }

    pSession->get_dbConn()->commit();

    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::node_checkPass ok.");
    return 0;
}

int CFlowTaskMonitor::node_checkNoPass (
    SOBSession* pSession,
    int64 llTaskId,
    int32 nInstId,
    CBSErrorMsg& cErrorMsg )
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::node_checkNoPass ok.");

        int nExecNum = 0;
    ob_whereCond cFullSql;
    cFullSql << OCS(" update fm_task_node_info set sts = ")
             << NODE_STS_FAILD
             << OCS(" where subtask_id = ")
             << llTaskId
             << OCS(" and inst_id = ")
             << nInstId
             << OCS(" and sts = ")
             << NODE_STS_NEED_CHECK;

    if (directExec (
            pSession,
            cFullSql,
            nExecNum,
            cErrorMsg))
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","call directExec error.");
        return -1;
    }

    if (nExecNum != 1)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","update task_node_info checknopass error, update num is not 1");
        return -1;
    }

    pSession->get_dbConn()->commit();

    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::node_checkNoPass ok.");
    return 0;
}

int CFlowTaskMonitor::call_opFunc (const AISTD string& strBuf)
{

    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::call_opFunc ok.");

    SOBSession *pSession;
    CThreadValueHolder cThreadValueHolder; 
    try                                   
    {         	                 
        if (CThreadValueMgr::set_value(OBD_SESSION_NAME, SOBSession()) < 0)                    
        {                                                                                              
            LogAppend(FATAL_LEVEL, "DebugInfo", "CFlowTaskMonitor::runNode 初始化数据库容器错误!");                  
            return NULL;
        }                                                                                       
        pSession = CThreadValueMgr::get_value<SOBSession>(OBD_SESSION_NAME);                   
        pSession->m_pDbConn = pSession->get_dbConn();                                         
    }                                                                                           
    catch(...)                                                                                
    {                                                                                        
        LogAppend(FATAL_LEVEL, "DebugInfo", "初始化数据库容器错误!");
        return NULL;
    }                                                     

	CBSErrorMsg cErrorMsg;
	vector result=CutString(strBuf,"|"); 
    llTaskId   = atoi((result[0]).c_str()); 
    nInstId    = atoi((result[1]).c_str());
    interface  = result[2];
	std::cout<<"interface: "<<interface<<std::endl;
												
												
/*	std::auto_ptr< CDmcextTemplateMgr<CFmTaskList> > tFmTask = CDmcextAuditMgr::getFmTask(pSession);
	CFmTask fmTask;
    CFmTaskList fmTaskList;
	fmTask.set_taskId(llTaskId);
	tFmTask->selectFromTable(fmTask,"", fmTaskList, cErrorMsg);
	int32 flow_id=get_flowId();*/
    CFmTaskList fmTaskList;
	AISTD string cond;
	int32 flow_id;
	cond=AISTD string("subtask_id = ") + AISTD string(itoa(llTaskId));
	FmTaskOp::get_fmTask(pSession,cond,fmTaskList,cErrorMsg);
	if(fmTaskList.empty())
		LogAppend(FATAL_LEVEL, "DebugInfo", "没有可供查询的任务!");	
	else
    {	flow_id=fmTaskList[0].get_flowId();
		std::cout<<"flow_id"<<flow_id<<std::endl;
	}

	std::auto_ptr< CDmcextTemplateMgr<CFmFlowNodeInfoList> > tFmFlowNodeInfo = CDmcextAuditMgr::getFmFlowNodeInfo(pSession);
	CFmFlowNodeInfo fmFlowNodeInfo;
	CFmFlowNodeInfoList fmFlowNodeInfoList;
	fmFlowNodeInfo.set_flowId(flow_id);
	fmFlowNodeInfo.set_instId(nInstId);
	//tFmFlowNodeInfo->selectFromTable(fmFlowNodeInfo, " to_char(valid_date,'yyyy-mm-dd') between '2014-04-29' and '2014-05-02' ", fmFlowNodeInfoList, cErrorMsg);
	tFmFlowNodeInfo->selectFromTable(fmFlowNodeInfo, "", fmFlowNodeInfoList, cErrorMsg);

	int32 node_id=fmFlowNodeInfoList[1].get_nodeId();
	std::cout<<"node_id"<<node_id<<std::endl;

	std::auto_ptr< CDmcextTemplateMgr<CFmNodeDefineList> > tFmNodeDefine = CDmcextAuditMgr::getFmNodeDefine(pSession);
	CFmNodeDefine fmNodeDefine;
	CFmNodeDefineList fmNodeDefineList;
	fmNodeDefine.set_nodeId(node_id);
	tFmNodeDefine->selectFromTable(fmNodeDefine, "", fmNodeDefineList, cErrorMsg);
	int32 script_id=fmNodeDefineList[2].get_scriptId();
	std::cout<<"script_id"<<script_id<<std::endl;

    std::auto_ptr< CDmcextTemplateMgr<CFmNodeScriptDefineList> > tFmNodeScriptDefine = CDmcextAuditMgr::getFmNodeScriptDefine(pSession);
    CFmNodeScriptDefine fmNodeScriptDefine;
    CFmNodeScriptDefineList fmNodeScriptDefineList;
    fmNodeScriptDefine.set_scriptId(script_id);
	tFmNodeScriptDefine->selectFromTable(fmNodeScriptDefine, "", fmNodeScriptDefineList, cErrorMsg);
	AISTD string script_name=fmNodeScriptDefineList[9].get_scriptName();
    std::cout<<"script_name"<<script_name<<std::endl;

	InterExec(script_name,interface);

    
    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::call_opFunc ok.");
    return 0;
}

void* CFlowTaskMonitor::opHandle (void* pArg)
{
    LogAppend(DEBUG_LEVEL,"InfoLevel","enter CFlowTaskMonitor::opHandle ok.");

    CFlowTaskMonitor* pThis = (CFlowTaskMonitor*) pArg;

    char buf[MAX_BUF_SIZE];
    int nRecvCount = 0;

    int fdConnect = 0;

    pthread_mutex_lock(&SOCK_THREAD_MTX);

    if (pThis->m_listFdConnect.empty())
    {
        pthread_mutex_unlock(&SOCK_THREAD_MTX);
        return NULL;
    }
    else
    {
        fdConnect = pThis->m_listFdConnect[0];
        pThis->m_listFdConnect.erase(pThis->m_listFdConnect.begin());
    }
    
    pthread_mutex_unlock(&SOCK_THREAD_MTX);

    memset(buf, 0, MAX_BUF_SIZE);

    nRecvCount = recv(fdConnect, buf, MAX_BUF_SIZE - 1, 0);
    if (0 > nRecvCount)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel",AISTD string(AISTD string("recv socket error : ") + AISTD string(strerror(errno))).c_str());
        close(fdConnect);
        return NULL;
    }

    if (0 == nRecvCount)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","recv data length is 0 !");
        close(fdConnect);
        return NULL;
    }

    if (MAX_BUF_SIZE - 1 <= nRecvCount)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","recv data length is too long !");
        close(fdConnect);
        return NULL;
    }

    AISTD string strBuf(buf);
    LogAppend(DEBUG_LEVEL,"InfoLevel", AISTD string(AISTD string("recv buf content is : ") + strBuf).c_str());
    if (pThis->call_opFunc (strBuf))
	{
          LogAppend(DEBUG_LEVEL,"InfoLevel","call call_opFunc error.");
    }
	else
	{
		  LogAppend(DEBUG_LEVEL,"InfoLevel","call call_opFunc success.");
    }

    if (send(fdConnect, buf, strlen(buf), 0) < 0)
    {
        LogAppend(DEBUG_LEVEL,"InfoLevel","send socket error.");
    }
    close(fdConnect);

    sleep(5);

    pthread_mutex_lock(&SOCK_THREAD_MTX);
    pThis->m_sockThreadCnt = pThis->m_sockThreadCnt - 1;
    pthread_mutex_unlock(&SOCK_THREAD_MTX);

    LogAppend(DEBUG_LEVEL,"InfoLevel",AISTD string(AISTD string("opHandle m_sockThreadCnt: ") + AISTD string(itoa(pThis->m_sockThreadCnt))).c_str());

    LogAppend(DEBUG_LEVEL,"InfoLevel","leave CFlowTaskMonitor::opHandle ok.");
    return NULL;
}
